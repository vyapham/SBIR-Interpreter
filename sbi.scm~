#!/afs/cats.ucsc.edu/courses/cmps112-wm/usr/racket/bin/mzscheme -qr

(define *function-table* (make-hash))
(for-each
  (lambda (function) (hash-set! *function-table*  (car function) (cadr function)))
    `(
      (+, +)
      (-, -)
      (*, *)
      (/, (lambda (a b) (/ a b)))
      (abs, abs)
      (acos, acos)
      (asin, asin)
      (atan, atan)
      (ceil, ceiling)
      (cos, cos)
      (sin, sin)
      (tan, tan)
      (exp, exp)
      (round, round)
      (floor, floor)
;      (log, )
;      (log10, )
;      (log2, )
      (sqrt, sqrt)
      (trunc, truncate)
      (=, equal?)
      (<> , (lambda (x y) (not (equal? x y))))
      (<=, <=)
      (>=, >=)
      (<, <)
      (>, >)
      (^, expt)
    )
)

(define *variable-table* (make-hash))
(
  for-each
    (lambda (variable) (hash-set! *variable-table* (car variable) (cadr variable)))
    `(
      (pi 3.141592653589793238462643383279502884197169399)
      (e 2.718281828459045235360287471352662497757247093)
    )
)

(define (statement-eval statement)
  (cond
    (
      (eqv? (car statement) 'dim)
      ;; dim-statement
      (dim-statement (car(cadr statement)) (cadr(cadr statement)) )
    )
    (
      (eqv? (car statement) 'let)
      ;; let-statement
      (let-statement (car(cadr statement)) (cadr(cadr statement)))
    )
    (
      (eqv? (car statement) 'goto)
      ;; goto-statement
      (goto-statement (cadr statement))
    )
    (
      (eqv? (car statement) 'if)
      ;; if-statement
      (if-statement (cadr statement) (caddr statement))
    )
    (
      (eqv? (car statement) 'print)
      ;; print-statement
      (begin (print-statement (cdr statement)) (printf "~n"))
      
    )
    (
      (eqv? (car statement) 'input)
      ;; input
    )
  )
)

(define (dim-statement var expression)
  (hash-set! *variable-table* var (make-vector (expression-eval expression)))
)

(define (let-statement var expression)
  (cond
    (
      (symbol? var) (hash-set! *variable-table* var (expression-eval expression))
    )
    (
      (pair? var)
      (if (and (vector? (car var)) (<= (cadr var) (vector-length (hash-ref *variable-table* (car var)))))
        (vector-set!
          (hash-ref *variable-table* (car var))
          (cadr var)
          (expression-eval expression)
        )
        (printf("Error!"))
      )
    )
  )
)

(define (goto-statement label)
  (if (hash-has-key? *label-table* label)
  ;; if the label is in the label-table, execute the program from the label
    (statement-eval (hash-ref *label-table* label))
  ;; if not, print error
    (void)
  )
)

(define (if-statement condition label)
  (if ((hash-ref *function-table* (car condition)) (expression-eval (car(cdr condition))) (expression-eval (cadr(cdr condition))) )
    (goto-statement label)
    (void)
  )
)

(define (print-statement toPrint)
  (when (not (null? toPrint))
      (if (string? (car toPrint))
        (printf "~a " (car toPrint))
        (printf "~a " (expression-eval (car toPrint)))
      )
      (print-statement (cdr toPrint))
  )
)

;(define (input-statement )

;)

(define (expression-eval expression)
  (cond
    ;; If symbol or number, convert to float by adding 0.0
    (
      (symbol? expression) (+ (hash-ref *variable-table* expression) 0.0)
    )
    (
      (number? expression) (+ expression 0.0)
    )
    (
    ;; If pair, check in function-table and run the function. If not in the table, that's a variable
      (pair? expression)
      (if (hash-has-key? *function-table* (car expression))
        (apply (hash-ref *function-table* (car expression)) (map expression-eval (cdr expression)) )
        (void)
      )
    )
  )
)

(define *stdin* (current-input-port))
(define *stdout* (current-output-port))
(define *stderr* (current-error-port))

(define *run-file*
    (let-values
        (((dirpath basepath root?)
            (split-path (find-system-path 'run-file))))
        (path->string basepath))
)

(define (die list)
    (for-each (lambda (item) (display item *stderr*)) list)
    (newline *stderr*)
    (exit 1)
)

(define (usage-exit)
    (die `("Usage: " ,*run-file* " filename"))
)

(define (readlist-from-inputfile filename)
    (let ((inputfile (open-input-file filename)))
         (if (not (input-port? inputfile))
             (die `(,*run-file* ": " ,filename ": open failed"))
             (let ((program (read inputfile)))
                  (close-input-port inputfile)
                         program))))

;(define (write-program-by-line filename program)
;    (printf "==================================================~n")
;    (printf "~a: ~s~n" *run-file* filename)
;    (printf "==================================================~n")
;    (printf "(~n")
;      (map (lambda (line) (printf "~s~n" line)) program)
;      (printf ")~n"
;    )
;)

(define *label-table* (make-hash))

;; program ~ list
(define (make-labels program)
  (if (= (length (car program)) 1)
    (make-labels (cdr program))
    ;; else if a symbol
    (if (symbol? (cadr (car program) ))
      (hash-set! *label-table* (cadr program) (cdr program) )
      ;; else
      (make-labels)
    )
  )
)

;; program ~ list
(define (run-program program)
  (if (not(null? program))
    (if (= (length (car program)) 1)
      (run-program (cdr program))
      (if (symbol? (cadr(car program)))
        (when (not(null? (caddr(car program))))
          (statement-eval (caddr(car program)))
          (run-program (hash-ref *label-table* (cadr(car program))) )
        )
        (when (list? (cadr(car program)))
          (statement-eval (cadr(car program)))
          (run-program (cdr program))
        )
      )
    )
    (void)
  )
)

(define (main arglist)
    (if (or (null? arglist) (not (null? (cdr arglist))))
        (usage-exit)
        (let* (
                (sbprogfile (car arglist))
                (program (readlist-from-inputfile sbprogfile))
              )

;              (write-program-by-line sbprogfile program)
              (make-labels program)
              (run-program program)
        )
    )
)

(when (terminal-port? *stdin*)
      (main (vector->list (current-command-line-arguments))))
